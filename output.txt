The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
src/test/java/com/questApplication/questApplication/QuestApplicationTests.java
package com.questApplication.questApplication;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class QuestApplicationTests {

	@Test
	void contextLoads() {
	}

}

----
src/test/java/com/questApplication/questApplication/business/concretes/UserManagerTest.java
package com.questApplication.questApplication.business.concretes;

public
class UserManagerTest {
}

----
src/main/java/com/questApplication/questApplication/QuestApplication.java
package com.questApplication.questApplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class QuestApplication {

	public static void main(String[] args) {
		SpringApplication.run(QuestApplication.class, args);
	}

}

----
src/main/java/com/questApplication/questApplication/configuration/SecurityConfig.java
package com.questApplication.questApplication.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/**", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .httpBasic(httpBasic -> {})
                .formLogin(formLogin -> {});

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder passwordEncoder) {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder.encode("password"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
----
src/main/java/com/questApplication/questApplication/configuration/WebConfig.java
package com.questApplication.questApplication.configuration;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000") // Ã–nce * kullanmadan deneyin
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}

----
src/main/java/com/questApplication/questApplication/repository/CommentRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Comment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    Page<Comment> findByPostIdAndStatusNot(Long postId, String status, Pageable pageable);
    Page<Comment> findByUserIdAndStatusNot(Long userId, String status, Pageable pageable);
    Optional<Comment> findByIdAndStatusNot(Long id, String status);
}
----
src/main/java/com/questApplication/questApplication/repository/LikeRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Like;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface LikeRepository extends JpaRepository<Like, Long> {
    Page<Like> findByPostId(Long postId, Pageable pageable);
    boolean existsByPostIdAndUserId(Long postId, Long userId);
    long countByPostId(Long postId);
}
----
src/main/java/com/questApplication/questApplication/repository/PostRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Post;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    Page<Post> findAllByStatusNot(String status, Pageable pageable);
    Optional<Post> findByIdAndStatusNot(Long id, String status);
    Page<Post> findByUserIdAndStatusNot(Long userId, String status, Pageable pageable);
}
----
src/main/java/com/questApplication/questApplication/repository/UserRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findAllByStatusNot(String status, Pageable pageable);
    Optional<User> findByIdAndStatusNot(Long id, String status);
    Optional<User> findByUsernameAndStatusNot(String username, String status);
    boolean existsByUsername(String username);
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/SuccessResult.java
package com.questApplication.questApplication.core.utilities.result;

public class SuccessResult extends Result {
    public SuccessResult() {
        super(true);
    }

    public SuccessResult(String message) {
        super(true, message);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/ErrorResult.java
package com.questApplication.questApplication.core.utilities.result;


public class ErrorResult extends Result {
    public ErrorResult() {
        super(false);
    }

    public ErrorResult(String message) {
        super(false, message);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/ErrorDataResult.java
package com.questApplication.questApplication.core.utilities.result;

public class ErrorDataResult<T> extends DataResult<T> {
    public ErrorDataResult(T data, String message) {
        super(data, false, message);
    }

    public ErrorDataResult(T data) {
        super(data, false);
    }

    public ErrorDataResult(String message) {
        super(null, false, message);
    }

    public ErrorDataResult() {
        super(null, false);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/Result.java
package com.questApplication.questApplication.core.utilities.result;

public class Result {
    private final boolean success;
    private final String message;

    public Result(boolean success) {
        this(success, null);
    }

    public Result(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}

----
src/main/java/com/questApplication/questApplication/core/utilities/result/SuccessDataResult.java
package com.questApplication.questApplication.core.utilities.result;

public class SuccessDataResult<T> extends DataResult<T> {
    public SuccessDataResult(T data, String message) {
        super(data, true, message);
    }

    public SuccessDataResult(T data) {
        super(data, true);
    }

    public SuccessDataResult(String message) {
        super(null, true, message);
    }

    public SuccessDataResult() {
        super(null, true);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/DataResult.java
package com.questApplication.questApplication.core.utilities.result;


public class DataResult<T> extends Result {
    private final T data;

    public DataResult(T data, boolean success, String message) {
        super(success, message);
        this.data = data;
    }

    public DataResult(T data, boolean success) {
        this(data, success, null);
    }

    public T getData() {
        return data;
    }
}
----
src/main/java/com/questApplication/questApplication/entity/Post.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Entity
@Table(name = "posts")
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;

    private String title;
    private String text;
    private String status;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @OneToMany(mappedBy = "post")
    private List<Like> likes;

    @OneToMany(mappedBy = "post")
    private List<Comment> comments;
}

----
src/main/java/com/questApplication/questApplication/entity/User.java
package com.questApplication.questApplication.entity;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    Long id;

    String username;
    String password;
    String status;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Post> posts;

    @OneToMany(mappedBy = "user")
    private List<Comment> comments;

    @OneToMany(mappedBy = "user")
    private List<Like> likes;
}

----
src/main/java/com/questApplication/questApplication/entity/Like.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name="likes")
public class Like {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;

    String status;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;

    @ManyToOne
    @JoinColumn(name = "comment_id")
    private Comment comment;
}

----
src/main/java/com/questApplication/questApplication/entity/Comment.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String text;
    private String status;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;

    @OneToMany(mappedBy = "comment")
    private List<Like> likes;


}

----
src/main/java/com/questApplication/questApplication/entity/dto/PostDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class PostDTO {
    private Long id;
    private String title;
    private String status;
    private String text;
    private LocalDateTime createdAt;
    private UserDTO user;
    private List<LikeDTO> likes;
    private List<CommentDTO> comments;
}
----
src/main/java/com/questApplication/questApplication/entity/dto/LikeDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

@Data
public class LikeDTO {
    private Long id;
    private String status;
    private Long userId;
    private Long postId;
    private Long commentId;
}
----
src/main/java/com/questApplication/questApplication/entity/dto/UserDTO.java
package com.questApplication.questApplication.entity.dto;

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private String password;
    private String status;

    public Long getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public String getStatus() { return status; }

    public void setId(Long id) { this.id = id; }
    public void setUsername(String username) { this.username = username; }
    public void setEmail(String email) { this.email = email; }
    public void setPassword(String password) { this.password = password; }
    public void setStatus(String status) { this.status = status; }
}
----
src/main/java/com/questApplication/questApplication/entity/dto/CommentDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CommentDTO {
    private Long id;
    private String text;
    private String status;
    private LocalDateTime createdAt;
    private Long userId;
    private Long postId;
    private List<Long> likeIds;

}
----
src/main/java/com/questApplication/questApplication/business/concretes/PostManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.PostService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Post;
import com.questApplication.questApplication.entity.dto.PostDTO;
import com.questApplication.questApplication.mapper.PostMapper;
import com.questApplication.questApplication.repository.PostRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PostManager implements PostService {
    private static final Logger logger = LoggerFactory.getLogger(PostManager.class);
    private final PostRepository postRepository;
    private final PostMapper postMapper;

    @Autowired
    public PostManager(PostRepository postRepository, PostMapper postMapper) {
        this.postRepository = postRepository;
        this.postMapper = postMapper;
    }

    @Override
    public DataResult<Page<PostDTO>> getAllPosts(Pageable pageable) {
        logger.info("TÃ¼m gÃ¶nderiler getiriliyor. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Post> posts = postRepository.findAllByStatusNot("D", pageable);
            Page<PostDTO> postDTOs = posts.map(postMapper::toDTO);
            logger.info("Toplam {} gÃ¶nderi baÅŸarÄ±yla getirildi", postDTOs.getTotalElements());
            return new SuccessDataResult<>(postDTOs, "GÃ¶nderiler baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("GÃ¶nderiler getirilirken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "GÃ¶nderiler getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<PostDTO> getPostById(Long id) {
        logger.info("{} ID'li gÃ¶nderi getiriliyor", id);
        try {
            Post post = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (post != null) {
                PostDTO postDTO = postMapper.toDTO(post);
                logger.info("{} ID'li gÃ¶nderi baÅŸarÄ±yla getirildi", id);
                return new SuccessDataResult<>(postDTO, "GÃ¶nderi baÅŸarÄ±yla getirildi");
            } else {
                logger.warn("{} ID'li gÃ¶nderi bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "GÃ¶nderi bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderi getirilirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "GÃ¶nderi getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<Page<PostDTO>> getPostsByUserId(Long userId, Pageable pageable) {
        logger.info("{} ID'li kullanÄ±cÄ±nÄ±n gÃ¶nderileri getiriliyor. Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Post> posts = postRepository.findByUserIdAndStatusNot(userId, "D", pageable);
            Page<PostDTO> postDTOs = posts.map(postMapper::toDTO);
            logger.info("{} ID'li kullanÄ±cÄ±nÄ±n {} gÃ¶nderisi baÅŸarÄ±yla getirildi", userId, postDTOs.getTotalElements());
            return new SuccessDataResult<>(postDTOs, "KullanÄ±cÄ± gÃ¶nderileri baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ±nÄ±n gÃ¶nderileri getirilirken bir hata oluÅŸtu", userId, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± gÃ¶nderileri getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> createPost(PostDTO postDTO) {
        logger.info("Yeni gÃ¶nderi oluÅŸturuluyor");
        try {
            Post post = postMapper.toEntity(postDTO);
            post.setStatus("A"); // Active
            Post savedPost = postRepository.save(post);
            PostDTO savedPostDTO = postMapper.toDTO(savedPost);
            logger.info("{} ID'li yeni gÃ¶nderi baÅŸarÄ±yla oluÅŸturuldu", savedPostDTO.getId());
            return new SuccessDataResult<>(savedPostDTO, "GÃ¶nderi baÅŸarÄ±yla oluÅŸturuldu");
        } catch (Exception e) {
            logger.error("GÃ¶nderi oluÅŸturulurken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "GÃ¶nderi oluÅŸturulurken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> updatePost(Long id, PostDTO postDTO) {
        logger.info("{} ID'li gÃ¶nderi gÃ¼ncelleniyor", id);
        try {
            Post existingPost = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingPost != null) {
                Post updatedPost = postMapper.toEntity(postDTO);
                updatedPost.setId(id);
                updatedPost.setStatus("U"); // Updated
                Post savedPost = postRepository.save(updatedPost);
                PostDTO savedPostDTO = postMapper.toDTO(savedPost);
                logger.info("{} ID'li gÃ¶nderi baÅŸarÄ±yla gÃ¼ncellendi", id);
                return new SuccessDataResult<>(savedPostDTO, "GÃ¶nderi baÅŸarÄ±yla gÃ¼ncellendi");
            } else {
                logger.warn("{} ID'li gÃ¶nderi bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "GÃ¼ncellenecek gÃ¶nderi bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderi gÃ¼ncellenirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "GÃ¶nderi gÃ¼ncellenirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public Result deletePost(Long id) {
        logger.info("{} ID'li gÃ¶nderi siliniyor (soft delete)", id);
        try {
            Post post = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (post != null) {
                post.setStatus("D"); // Deleted
                postRepository.save(post);
                logger.info("{} ID'li gÃ¶nderi baÅŸarÄ±yla silindi (soft delete)", id);
                return new SuccessResult("GÃ¶nderi baÅŸarÄ±yla silindi");
            } else {
                logger.warn("{} ID'li gÃ¶nderi bulunamadÄ±", id);
                return new ErrorResult("Silinecek gÃ¶nderi bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderi silinirken bir hata oluÅŸtu", id, e);
            return new ErrorResult("GÃ¶nderi silinirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> activatePost(Long id) {
        logger.info("{} ID'li gÃ¶nderi aktifleÅŸtiriliyor", id);
        try {
            Post post = postRepository.findById(id).orElse(null);
            if (post != null) {
                if (!post.getStatus().equals("A")) {
                    post.setStatus("A"); // Active
                    Post savedPost = postRepository.save(post);
                    PostDTO activatedPostDTO = postMapper.toDTO(savedPost);
                    logger.info("{} ID'li gÃ¶nderi baÅŸarÄ±yla aktifleÅŸtirildi", id);
                    return new SuccessDataResult<>(activatedPostDTO, "GÃ¶nderi baÅŸarÄ±yla aktifleÅŸtirildi");
                } else {
                    logger.warn("{} ID'li gÃ¶nderi zaten aktif", id);
                    return new ErrorDataResult<>(null, "GÃ¶nderi zaten aktif");
                }
            } else {
                logger.warn("{} ID'li gÃ¶nderi bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "AktifleÅŸtirilecek gÃ¶nderi bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderi aktifleÅŸtirilirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "GÃ¶nderi aktifleÅŸtirilirken bir hata oluÅŸtu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/concretes/LikeManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.LikeService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Like;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import com.questApplication.questApplication.mapper.LikeMapper;
import com.questApplication.questApplication.repository.LikeRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class LikeManager implements LikeService {
    private static final Logger logger = LoggerFactory.getLogger(LikeManager.class);
    private final LikeRepository likeRepository;
    private final LikeMapper likeMapper;

    public LikeManager(LikeRepository likeRepository, LikeMapper likeMapper) {
        this.likeRepository = likeRepository;
        this.likeMapper = likeMapper;
    }

    @Override
    public DataResult<Page<LikeDTO>> getAllLikes(Pageable pageable) {
        logger.info("TÃ¼m beÄŸeniler getiriliyor, Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Like> likes = likeRepository.findAll(pageable);
            Page<LikeDTO> likeDTOs = likes.map(likeMapper::toDTO);
            logger.info("Toplam {} beÄŸeni baÅŸarÄ±yla getirildi", likeDTOs.getTotalElements());
            return new SuccessDataResult<>(likeDTOs, "TÃ¼m beÄŸeniler baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("BeÄŸeniler getirilirken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "BeÄŸeniler getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<Page<LikeDTO>> getLikesByPostId(Long postId, Pageable pageable) {
        logger.info("{} ID'li gÃ¶nderinin beÄŸenileri getiriliyor, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Like> likes = likeRepository.findByPostId(postId, pageable);
            Page<LikeDTO> likeDTOs = likes.map(likeMapper::toDTO);
            logger.info("{} ID'li gÃ¶nderinin {} beÄŸenisi baÅŸarÄ±yla getirildi", postId, likeDTOs.getTotalElements());
            return new SuccessDataResult<>(likeDTOs, "GÃ¶nderi beÄŸenileri baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderinin beÄŸenileri getirilirken bir hata oluÅŸtu", postId, e);
            return new ErrorDataResult<>(null, "GÃ¶nderi beÄŸenileri getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public Result createLike(LikeDTO likeDTO) {
        logger.info("Yeni beÄŸeni oluÅŸturuluyor");
        try {
            if (likeRepository.existsByPostIdAndUserId(likeDTO.getPostId(), likeDTO.getUserId())) {
                logger.warn("Bu gÃ¶nderi zaten bu kullanÄ±cÄ± tarafÄ±ndan beÄŸenilmiÅŸ");
                return new ErrorResult("Bu gÃ¶nderiyi zaten beÄŸenmiÅŸsiniz");
            }
            Like like = likeMapper.toEntity(likeDTO);
            likeRepository.save(like);
            logger.info("Yeni beÄŸeni baÅŸarÄ±yla oluÅŸturuldu");
            return new SuccessResult("BeÄŸeni baÅŸarÄ±yla oluÅŸturuldu");
        } catch (Exception e) {
            logger.error("BeÄŸeni oluÅŸturulurken bir hata oluÅŸtu", e);
            return new ErrorResult("BeÄŸeni oluÅŸturulurken bir hata oluÅŸtu");        }
    }

    @Override
    public DataResult<Long> getLikeCountForPost(Long postId) {
        logger.info("{} ID'li gÃ¶nderinin beÄŸeni sayÄ±sÄ± getiriliyor", postId);
        try {
            long likeCount = likeRepository.countByPostId(postId);
            logger.info("{} ID'li gÃ¶nderinin beÄŸeni sayÄ±sÄ±: {}", postId, likeCount);
            return new SuccessDataResult<>(likeCount, "GÃ¶nderi beÄŸeni sayÄ±sÄ± baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderinin beÄŸeni sayÄ±sÄ± getirilirken bir hata oluÅŸtu", postId, e);
            return new ErrorDataResult<>(null, "GÃ¶nderi beÄŸeni sayÄ±sÄ± getirilirken bir hata oluÅŸtu");
        }
    }


}
----
src/main/java/com/questApplication/questApplication/business/concretes/UserManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.UserService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.User;
import com.questApplication.questApplication.entity.dto.UserDTO;
import com.questApplication.questApplication.mapper.UserMapper;
import com.questApplication.questApplication.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserManager implements UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserManager.class);
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public UserManager(UserRepository userRepository, UserMapper userMapper, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public DataResult<Page<UserDTO>> getAllUsers(Pageable pageable) {
        logger.info("TÃ¼m kullanÄ±cÄ±lar getiriliyor. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<User> users = userRepository.findAllByStatusNot("D", pageable);
            Page<UserDTO> userDTOs = users.map(userMapper::toDTO);
            logger.info("Toplam {} kullanÄ±cÄ± baÅŸarÄ±yla getirildi", userDTOs.getTotalElements());
            return new SuccessDataResult<>(userDTOs, "KullanÄ±cÄ±lar baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("KullanÄ±cÄ±lar getirilirken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ±lar getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<UserDTO> getUserById(Long id) {
        logger.info("{} ID'li kullanÄ±cÄ± getiriliyor", id);
        try {
            User user = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (user != null) {
                UserDTO userDTO = userMapper.toDTO(user);
                logger.info("{} ID'li kullanÄ±cÄ± baÅŸarÄ±yla getirildi", id);
                return new SuccessDataResult<>(userDTO, "KullanÄ±cÄ± baÅŸarÄ±yla getirildi");
            } else {
                logger.warn("{} ID'li kullanÄ±cÄ± bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "KullanÄ±cÄ± bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ± getirilirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<UserDTO> createUser(UserDTO userDTO) {
        logger.info("Yeni kullanÄ±cÄ± oluÅŸturuluyor");
        try {
            if (userRepository.existsByUsername(userDTO.getUsername())) {
                logger.warn("Bu kullanÄ±cÄ± adÄ± zaten kullanÄ±lÄ±yor: {}", userDTO.getUsername());
                return new ErrorDataResult<>(null, "Bu kullanÄ±cÄ± adÄ± zaten kullanÄ±lÄ±yor");
            }

            User user = userMapper.toEntity(userDTO);
            user.setPassword(passwordEncoder.encode(userDTO.getPassword()));
            user.setStatus("A"); // Active
            User savedUser = userRepository.save(user);
            UserDTO savedUserDTO = userMapper.toDTO(savedUser);
            logger.info("{} ID'li yeni kullanÄ±cÄ± baÅŸarÄ±yla oluÅŸturuldu", savedUserDTO.getId());
            return new SuccessDataResult<>(savedUserDTO, "KullanÄ±cÄ± baÅŸarÄ±yla oluÅŸturuldu");
        } catch (Exception e) {
            logger.error("KullanÄ±cÄ± oluÅŸturulurken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± oluÅŸturulurken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<UserDTO> updateUser(Long id, UserDTO userDTO) {
        logger.info("{} ID'li kullanÄ±cÄ± gÃ¼ncelleniyor", id);
        try {
            User existingUser = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingUser != null) {
                User updatedUser = userMapper.toEntity(userDTO);
                updatedUser.setId(id);
                updatedUser.setStatus("U");

                if (userDTO.getPassword() == null || userDTO.getPassword().isEmpty()) {
                    updatedUser.setPassword(existingUser.getPassword());
                } else {
                    updatedUser.setPassword(passwordEncoder.encode(userDTO.getPassword()));
                }

                User savedUser = userRepository.save(updatedUser);
                UserDTO savedUserDTO = userMapper.toDTO(savedUser);
                logger.info("{} ID'li kullanÄ±cÄ± baÅŸarÄ±yla gÃ¼ncellendi", id);
                return new SuccessDataResult<>(savedUserDTO, "KullanÄ±cÄ± baÅŸarÄ±yla gÃ¼ncellendi");
            } else {
                logger.warn("{} ID'li kullanÄ±cÄ± bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "GÃ¼ncellenecek kullanÄ±cÄ± bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ± gÃ¼ncellenirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± gÃ¼ncellenirken bir hata oluÅŸtu");
        }
    }


    @Override
    @Transactional
    public Result deleteUser(Long id) {
        logger.info("{} ID'li kullanÄ±cÄ± siliniyor (soft delete)", id);
        try {
            User user = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (user != null) {
                user.setStatus("D");
                userRepository.save(user);
                logger.info("{} ID'li kullanÄ±cÄ± baÅŸarÄ±yla silindi (soft delete)", id);
                return new SuccessResult("KullanÄ±cÄ± baÅŸarÄ±yla silindi");
            } else {
                logger.warn("{} ID'li kullanÄ±cÄ± bulunamadÄ±", id);
                return new ErrorResult("Silinecek kullanÄ±cÄ± bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ± silinirken bir hata oluÅŸtu", id, e);
            return new ErrorResult("KullanÄ±cÄ± silinirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<UserDTO> getUserByUsername(String username) {
        logger.info("{} kullanÄ±cÄ± adÄ±na sahip kullanÄ±cÄ± getiriliyor", username);
        try {
            User user = userRepository.findByUsernameAndStatusNot(username, "D").orElse(null);
            if (user != null) {
                UserDTO userDTO = userMapper.toDTO(user);
                logger.info("{} kullanÄ±cÄ± adÄ±na sahip kullanÄ±cÄ± baÅŸarÄ±yla getirildi", username);
                return new SuccessDataResult<>(userDTO, "KullanÄ±cÄ± baÅŸarÄ±yla getirildi");
            } else {
                logger.warn("{} kullanÄ±cÄ± adÄ±na sahip kullanÄ±cÄ± bulunamadÄ±", username);
                return new ErrorDataResult<>(null, "KullanÄ±cÄ± bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} kullanÄ±cÄ± adÄ±na sahip kullanÄ±cÄ± getirilirken bir hata oluÅŸtu", username, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± getirilirken bir hata oluÅŸtu");
        }
    }


    @Override
    @Transactional
    public DataResult<UserDTO> activateUser(Long id) {
        logger.info("{} ID'li kullanÄ±cÄ± aktifleÅŸtiriliyor", id);
        try {
            User user = userRepository.findById(id).orElse(null);
            if (user != null) {
                if (!user.getStatus().equals("A")) {
                    user.setStatus("A");
                    User savedUser = userRepository.save(user);
                    UserDTO activatedUserDTO = userMapper.toDTO(savedUser);
                    logger.info("{} ID'li kullanÄ±cÄ± baÅŸarÄ±yla aktifleÅŸtirildi", id);
                    return new SuccessDataResult<>(activatedUserDTO, "KullanÄ±cÄ± baÅŸarÄ±yla aktifleÅŸtirildi");
                } else {
                    logger.warn("{} ID'li kullanÄ±cÄ± zaten aktif", id);
                    return new ErrorDataResult<>(null, "KullanÄ±cÄ± zaten aktif");
                }
            } else {
                logger.warn("{} ID'li kullanÄ±cÄ± bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "AktifleÅŸtirilecek kullanÄ±cÄ± bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ± aktifleÅŸtirilirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ± aktifleÅŸtirilirken bir hata oluÅŸtu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/concretes/CommentManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.CommentService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Comment;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import com.questApplication.questApplication.mapper.CommentMapper;
import com.questApplication.questApplication.repository.CommentRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CommentManager implements CommentService {
    private static final Logger logger = LoggerFactory.getLogger(CommentManager.class);
    private final CommentRepository commentRepository;
    private final CommentMapper commentMapper;

    @Autowired
    public CommentManager(CommentRepository commentRepository, CommentMapper commentMapper) {
        this.commentRepository = commentRepository;
        this.commentMapper = commentMapper;
    }

    @Override
    public DataResult<Page<CommentDTO>> getCommentsByPostId(Long postId, Pageable pageable) {
        logger.info("{} ID'li gÃ¶nderinin yorumlarÄ± getiriliyor. Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Comment> comments = commentRepository.findByPostIdAndStatusNot(postId, "D", pageable);
            Page<CommentDTO> commentDTOs = comments.map(commentMapper::toDTO);
            logger.info("{} ID'li gÃ¶nderinin {} yorumu baÅŸarÄ±yla getirildi", postId, commentDTOs.getTotalElements());
            return new SuccessDataResult<>(commentDTOs, "Yorumlar baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gÃ¶nderinin yorumlarÄ± getirilirken bir hata oluÅŸtu", postId, e);
            return new ErrorDataResult<>(null, "Yorumlar getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<Page<CommentDTO>> getCommentsByUserId(Long userId, Pageable pageable) {
        logger.info("{} ID'li kullanÄ±cÄ±nÄ±n yorumlarÄ± getiriliyor. Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Comment> comments = commentRepository.findByUserIdAndStatusNot(userId, "D", pageable);
            Page<CommentDTO> commentDTOs = comments.map(commentMapper::toDTO);
            logger.info("{} ID'li kullanÄ±cÄ±nÄ±n {} yorumu baÅŸarÄ±yla getirildi", userId, commentDTOs.getTotalElements());
            return new SuccessDataResult<>(commentDTOs, "KullanÄ±cÄ±nÄ±n yorumlarÄ± baÅŸarÄ±yla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li kullanÄ±cÄ±nÄ±n yorumlarÄ± getirilirken bir hata oluÅŸtu", userId, e);
            return new ErrorDataResult<>(null, "KullanÄ±cÄ±nÄ±n yorumlarÄ± getirilirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<CommentDTO> createComment(CommentDTO commentDTO) {
        logger.info("Yeni yorum oluÅŸturuluyor");
        try {
            Comment comment = commentMapper.toEntity(commentDTO);
            comment.setStatus("A"); // Active
            Comment savedComment = commentRepository.save(comment);
            CommentDTO savedCommentDTO = commentMapper.toDTO(savedComment);
            logger.info("{} ID'li yeni yorum baÅŸarÄ±yla oluÅŸturuldu", savedCommentDTO.getId());
            return new SuccessDataResult<>(savedCommentDTO, "Yorum baÅŸarÄ±yla oluÅŸturuldu");
        } catch (Exception e) {
            logger.error("Yorum oluÅŸturulurken bir hata oluÅŸtu", e);
            return new ErrorDataResult<>(null, "Yorum oluÅŸturulurken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public DataResult<CommentDTO> updateComment(Long id, CommentDTO commentDTO) {
        logger.info("{} ID'li yorum gÃ¼ncelleniyor", id);
        try {
            Comment existingComment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingComment != null) {
                Comment updatedComment = commentMapper.toEntity(commentDTO);
                updatedComment.setId(id);
                updatedComment.setStatus("U"); // Updated
                Comment savedComment = commentRepository.save(updatedComment);
                CommentDTO savedCommentDTO = commentMapper.toDTO(savedComment);
                logger.info("{} ID'li yorum baÅŸarÄ±yla gÃ¼ncellendi", id);
                return new SuccessDataResult<>(savedCommentDTO, "Yorum baÅŸarÄ±yla gÃ¼ncellendi");
            } else {
                logger.warn("{} ID'li yorum bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "GÃ¼ncellenecek yorum bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum gÃ¼ncellenirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "Yorum gÃ¼ncellenirken bir hata oluÅŸtu");
        }
    }

    @Override
    @Transactional
    public Result deleteComment(Long id) {
        logger.info("{} ID'li yorum siliniyor (soft delete)", id);
        try {
            Comment comment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (comment != null) {
                comment.setStatus("D"); // Deleted
                commentRepository.save(comment);
                logger.info("{} ID'li yorum baÅŸarÄ±yla silindi (soft delete)", id);
                return new SuccessResult("Yorum baÅŸarÄ±yla silindi");
            } else {
                logger.warn("{} ID'li yorum bulunamadÄ±", id);
                return new ErrorResult("Silinecek yorum bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum silinirken bir hata oluÅŸtu", id, e);
            return new ErrorResult("Yorum silinirken bir hata oluÅŸtu");
        }
    }

    @Override
    public DataResult<CommentDTO> getCommentById(Long id) {
        logger.info("{} ID'li yorum getiriliyor", id);
        try {
            Comment comment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (comment != null) {
                CommentDTO commentDTO = commentMapper.toDTO(comment);
                logger.info("{} ID'li yorum baÅŸarÄ±yla getirildi", id);
                return new SuccessDataResult<>(commentDTO, "Yorum baÅŸarÄ±yla getirildi");
            } else {
                logger.warn("{} ID'li yorum bulunamadÄ±", id);
                return new ErrorDataResult<>(null, "Yorum bulunamadÄ±");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum getirilirken bir hata oluÅŸtu", id, e);
            return new ErrorDataResult<>(null, "Yorum getirilirken bir hata oluÅŸtu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/LikeService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface LikeService {
    DataResult<Page<LikeDTO>> getAllLikes ( Pageable pageable );
    DataResult<Page<LikeDTO>> getLikesByPostId(Long postId, Pageable pageable);
    Result createLike(LikeDTO likeDTO);
    DataResult<Long> getLikeCountForPost(Long postId);
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/UserService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.UserDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface UserService {
    DataResult<Page<UserDTO>> getAllUsers(Pageable pageable);
    DataResult<UserDTO> getUserById(Long id);
    DataResult<UserDTO> createUser(UserDTO userDTO);
    DataResult<UserDTO> updateUser(Long id, UserDTO userDTO);
    Result deleteUser(Long id);
    DataResult<UserDTO> getUserByUsername(String username);
    DataResult<UserDTO> activateUser(Long id);
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/CommentService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface CommentService {
    DataResult<Page<CommentDTO>> getCommentsByPostId(Long postId, Pageable pageable);
    DataResult<Page<CommentDTO>> getCommentsByUserId(Long userId, Pageable pageable);
    DataResult<CommentDTO> createComment(CommentDTO commentDTO);
    DataResult<CommentDTO> updateComment(Long id, CommentDTO commentDTO);
    Result deleteComment(Long id);
    DataResult<CommentDTO> getCommentById(Long id);
}

----
src/main/java/com/questApplication/questApplication/business/abstracts/PostService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.PostDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface PostService {
    DataResult<Page<PostDTO>> getAllPosts(Pageable pageable);
    DataResult<PostDTO> getPostById(Long id);
    DataResult<Page<PostDTO>> getPostsByUserId(Long userId, Pageable pageable);
    DataResult<PostDTO> createPost(PostDTO postDTO);
    DataResult<PostDTO> updatePost(Long id, PostDTO postDTO);
    Result deletePost(Long id);
    DataResult<PostDTO> activatePost(Long id);
}
----
src/main/java/com/questApplication/questApplication/mapper/CommentMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Comment;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CommentMapper {
    CommentDTO toDTO( Comment comment);
    Comment toEntity(CommentDTO commentDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/PostMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Post;
import com.questApplication.questApplication.entity.dto.PostDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring", uses = {UserMapper.class, LikeMapper.class, CommentMapper.class})
public interface PostMapper {
    PostDTO toDTO(Post post);
    Post toEntity(PostDTO postDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/LikeMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Like;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface LikeMapper {
    LikeDTO toDTO( Like like);
    Like toEntity(LikeDTO likeDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/UserMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.User;
import com.questApplication.questApplication.entity.dto.UserDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface UserMapper {
    UserDTO toDTO(User user);
    User toEntity(UserDTO userDTO);
}
----
src/main/java/com/questApplication/questApplication/api/controller/LikeController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.LikeService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/likes")
@Tag(name = "BeÄŸeni Denetleyicisi", description = "BeÄŸeni iÅŸlemlerini yÃ¶netir")
public class LikeController {

    private static final Logger logger = LoggerFactory.getLogger(LikeController.class);
    private final LikeService likeService;

    public LikeController(LikeService likeService) {
        this.likeService = likeService;
    }

    @GetMapping("/")
    @Operation(summary = "TÃ¼m beÄŸenileri getir", description = "TÃ¼m beÄŸenileri sayfalanmÄ±ÅŸ ÅŸekilde getirir")
    public ResponseEntity<DataResult<Page<LikeDTO>>> getAllLikes(Pageable pageable) {
        logger.debug("getAllLikes isteÄŸi alÄ±ndÄ±. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<LikeDTO>> result = likeService.getAllLikes(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }


    @GetMapping("/post/{postId}")
    @Operation(summary = "GÃ¶nderi ID'sine gÃ¶re beÄŸenileri getir", description = "Belirli bir gÃ¶nderiye ait sayfalanmÄ±ÅŸ beÄŸenileri getirir")
    public ResponseEntity<DataResult<Page<LikeDTO>>> getLikesByPostId(
            @PathVariable Long postId,
            Pageable pageable) {
        logger.debug("getLikesByPostId isteÄŸi alÄ±ndÄ±. Post ID: {}, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<LikeDTO>> result = likeService.getLikesByPostId(postId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping("/")
    @Operation(summary = "Yeni bir beÄŸeni oluÅŸtur", description = "Yeni bir beÄŸeni oluÅŸturur ve sonucu dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<Result> createLike(@Valid @RequestBody LikeDTO likeDTO) {
        logger.debug("createLike isteÄŸi alÄ±ndÄ±");
        Result result = likeService.createLike(likeDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @GetMapping("/count/{postId}")
    @Operation(summary = "GÃ¶nderi beÄŸeni sayÄ±sÄ±nÄ± getir", description = "Belirli bir gÃ¶nderinin toplam beÄŸeni sayÄ±sÄ±nÄ± getirir")
    public ResponseEntity<DataResult<Long>> getLikeCountForPost(@PathVariable Long postId) {
        logger.debug("getLikeCountForPost isteÄŸi alÄ±ndÄ±. Post ID: {}", postId);
        DataResult<Long> result = likeService.getLikeCountForPost(postId);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluÅŸtu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluÅŸtu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/CommentController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.CommentService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/comments")
@Tag(name = "Yorum Denetleyicisi", description = "Yorum iÅŸlemlerini yÃ¶netir")
public class CommentController {

    private static final Logger logger = LoggerFactory.getLogger(CommentController.class);
    private final CommentService commentService;

    public CommentController(CommentService commentService) {
        this.commentService = commentService;
    }

    @GetMapping("/post/{postId}")
    @Operation(summary = "GÃ¶nderi ID'sine gÃ¶re yorumlarÄ± getir", description = "Belirli bir gÃ¶nderiye ait sayfalanmÄ±ÅŸ yorumlarÄ± getirir")
    public ResponseEntity<DataResult<Page<CommentDTO>>> getCommentsByPostId(
            @PathVariable Long postId,
            Pageable pageable) {
        logger.debug("getCommentsByPostId isteÄŸi alÄ±ndÄ±. Post ID: {}, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<CommentDTO>> result = commentService.getCommentsByPostId(postId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "KullanÄ±cÄ± ID'sine gÃ¶re yorumlarÄ± getir", description = "Belirli bir kullanÄ±cÄ±ya ait sayfalanmÄ±ÅŸ yorumlarÄ± getirir")
    public ResponseEntity<DataResult<Page<CommentDTO>>> getCommentsByUserId(
            @PathVariable Long userId,
            Pageable pageable) {
        logger.debug("getCommentsByUserId isteÄŸi alÄ±ndÄ±. User ID: {}, Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<CommentDTO>> result = commentService.getCommentsByUserId(userId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping
    @Operation(summary = "Yeni bir yorum oluÅŸtur", description = "Yeni bir yorum oluÅŸturur ve oluÅŸturulan yorumu dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<CommentDTO>> createComment(@Valid @RequestBody CommentDTO commentDTO) {
        logger.debug("createComment isteÄŸi alÄ±ndÄ±");
        DataResult<CommentDTO> result = commentService.createComment(commentDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir yorumu gÃ¼ncelle", description = "Mevcut bir yorumu gÃ¼nceller ve gÃ¼ncellenmiÅŸ yorumu dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<CommentDTO>> updateComment(
            @PathVariable Long id,
            @Valid @RequestBody CommentDTO commentDTO) {
        logger.debug("updateComment isteÄŸi alÄ±ndÄ±. Comment ID: {}", id);
        DataResult<CommentDTO> result = commentService.updateComment(id, commentDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir yorumu sil", description = "Bir yorumu ID'sine gÃ¶re siler")
    public ResponseEntity<Result> deleteComment(@PathVariable Long id) {
        logger.debug("deleteComment isteÄŸi alÄ±ndÄ±. Comment ID: {}", id);
        Result result = commentService.deleteComment(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye gÃ¶re yorum getir", description = "Belirli bir yorumu ID'sine gÃ¶re getirir")
    public ResponseEntity<DataResult<CommentDTO>> getCommentById(@PathVariable Long id) {
        logger.debug("getCommentById isteÄŸi alÄ±ndÄ±. Comment ID: {}", id);
        DataResult<CommentDTO> result = commentService.getCommentById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluÅŸtu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluÅŸtu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/PostController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.PostService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.PostDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/posts")
@Tag(name = "GÃ¶nderi Denetleyicisi", description = "GÃ¶nderi iÅŸlemlerini yÃ¶netir")
public class PostController {

    private static final Logger logger = LoggerFactory.getLogger(PostController.class);
    private final PostService postService;

    public PostController(PostService postService) {
        this.postService = postService;
    }

    @GetMapping
    @Operation(summary = "TÃ¼m gÃ¶nderileri getir", description = "TÃ¼m gÃ¶nderileri sayfalanmÄ±ÅŸ ÅŸekilde getirir")
    public ResponseEntity<DataResult<Page<PostDTO>>> getAllPosts(Pageable pageable) {
        logger.debug("getAllPosts isteÄŸi alÄ±ndÄ±. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<PostDTO>> result = postService.getAllPosts(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye gÃ¶re gÃ¶nderi getir", description = "Belirli bir gÃ¶nderiyi ID'sine gÃ¶re getirir")
    public ResponseEntity<DataResult<PostDTO>> getPostById(@PathVariable Long id) {
        logger.debug("getPostById isteÄŸi alÄ±ndÄ±. Post ID: {}", id);
        DataResult<PostDTO> result = postService.getPostById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping
    @Operation(summary = "Yeni bir gÃ¶nderi oluÅŸtur", description = "Yeni bir gÃ¶nderi oluÅŸturur ve oluÅŸturulan gÃ¶nderiyi dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<PostDTO>> createPost(@Valid @RequestBody PostDTO postDTO) {
        logger.debug("createPost isteÄŸi alÄ±ndÄ±");
        DataResult<PostDTO> result = postService.createPost(postDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir gÃ¶nderiyi gÃ¼ncelle", description = "Mevcut bir gÃ¶nderiyi gÃ¼nceller ve gÃ¼ncellenmiÅŸ gÃ¶nderiyi dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<PostDTO>> updatePost(@PathVariable Long id, @Valid @RequestBody PostDTO postDTO) {
        logger.debug("updatePost isteÄŸi alÄ±ndÄ±. Post ID: {}", id);
        DataResult<PostDTO> result = postService.updatePost(id, postDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir gÃ¶nderiyi sil", description = "Bir gÃ¶nderiyi ID'sine gÃ¶re siler")
    public ResponseEntity<Result> deletePost(@PathVariable Long id) {
        logger.debug("deletePost isteÄŸi alÄ±ndÄ±. Post ID: {}", id);
        Result result = postService.deletePost(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "KullanÄ±cÄ±nÄ±n gÃ¶nderilerini getir", description = "Belirli bir kullanÄ±cÄ±nÄ±n gÃ¶nderilerini sayfalanmÄ±ÅŸ ÅŸekilde getirir")
    public ResponseEntity<DataResult<Page<PostDTO>>> getPostsByUserId(@PathVariable Long userId, Pageable pageable) {
        logger.debug("getPostsByUserId isteÄŸi alÄ±ndÄ±. User ID: {}, Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<PostDTO>> result = postService.getPostsByUserId(userId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluÅŸtu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluÅŸtu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/UserController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.UserService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.UserDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "KullanÄ±cÄ± Denetleyicisi", description = "KullanÄ±cÄ± iÅŸlemlerini yÃ¶netir")
public class UserController {

    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/")
    @Operation(summary = "TÃ¼m kullanÄ±cÄ±larÄ± getir", description = "TÃ¼m kullanÄ±cÄ±larÄ± sayfalanmÄ±ÅŸ ÅŸekilde getirir")
    public ResponseEntity<DataResult<Page<UserDTO>>> getAllUsers(Pageable pageable) {
        logger.debug("getAllUsers isteÄŸi alÄ±ndÄ±. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<UserDTO>> result = userService.getAllUsers(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye gÃ¶re kullanÄ±cÄ± getir", description = "Belirli bir kullanÄ±cÄ±yÄ± ID'sine gÃ¶re getirir")
    public ResponseEntity<DataResult<UserDTO>> getUserById(@PathVariable Long id) {
        logger.debug("getUserById isteÄŸi alÄ±ndÄ±. User ID: {}", id);
        DataResult<UserDTO> result = userService.getUserById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping("/")
    @Operation(summary = "Yeni bir kullanÄ±cÄ± oluÅŸtur", description = "Yeni bir kullanÄ±cÄ± oluÅŸturur ve oluÅŸturulan kullanÄ±cÄ±yÄ± dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<UserDTO>> createUser(@Valid @RequestBody UserDTO userDTO) {
        logger.debug("createUser isteÄŸi alÄ±ndÄ±");
        DataResult<UserDTO> result = userService.createUser(userDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir kullanÄ±cÄ±yÄ± gÃ¼ncelle", description = "Mevcut bir kullanÄ±cÄ±yÄ± gÃ¼nceller ve gÃ¼ncellenmiÅŸ kullanÄ±cÄ±yÄ± dÃ¶ndÃ¼rÃ¼r")
    public ResponseEntity<DataResult<UserDTO>> updateUser(@PathVariable Long id, @Valid @RequestBody UserDTO userDTO) {
        logger.debug("updateUser isteÄŸi alÄ±ndÄ±. User ID: {}", id);
        DataResult<UserDTO> result = userService.updateUser(id, userDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir kullanÄ±cÄ±yÄ± sil", description = "Bir kullanÄ±cÄ±yÄ± ID'sine gÃ¶re siler")
    public ResponseEntity<Result> deleteUser(@PathVariable Long id) {
        logger.debug("deleteUser isteÄŸi alÄ±ndÄ±. User ID: {}", id);
        Result result = userService.deleteUser(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluÅŸtu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluÅŸtu");
    }
}
--END--