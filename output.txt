The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
src/test/java/com/questApplication/questApplication/QuestApplicationTests.java
package com.questApplication.questApplication;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class QuestApplicationTests {

	@Test
	void contextLoads() {
	}

}

----
src/test/java/com/questApplication/questApplication/business/concretes/UserManagerTest.java
package com.questApplication.questApplication.business.concretes;

public
class UserManagerTest {
}

----
src/main/java/com/questApplication/questApplication/QuestApplication.java
package com.questApplication.questApplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class QuestApplication {

	public static void main(String[] args) {
		SpringApplication.run(QuestApplication.class, args);
	}

}

----
src/main/java/com/questApplication/questApplication/configuration/SecurityConfig.java
package com.questApplication.questApplication.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/**", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .httpBasic(httpBasic -> {})
                .formLogin(formLogin -> {});

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder passwordEncoder) {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder.encode("password"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
----
src/main/java/com/questApplication/questApplication/configuration/WebConfig.java
package com.questApplication.questApplication.configuration;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000") // Önce * kullanmadan deneyin
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}

----
src/main/java/com/questApplication/questApplication/repository/CommentRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Comment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    Page<Comment> findByPostIdAndStatusNot(Long postId, String status, Pageable pageable);
    Page<Comment> findByUserIdAndStatusNot(Long userId, String status, Pageable pageable);
    Optional<Comment> findByIdAndStatusNot(Long id, String status);
}
----
src/main/java/com/questApplication/questApplication/repository/LikeRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Like;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface LikeRepository extends JpaRepository<Like, Long> {
    Page<Like> findByPostId(Long postId, Pageable pageable);
    boolean existsByPostIdAndUserId(Long postId, Long userId);
    long countByPostId(Long postId);
}
----
src/main/java/com/questApplication/questApplication/repository/PostRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.Post;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    Page<Post> findAllByStatusNot(String status, Pageable pageable);
    Optional<Post> findByIdAndStatusNot(Long id, String status);
    Page<Post> findByUserIdAndStatusNot(Long userId, String status, Pageable pageable);
}
----
src/main/java/com/questApplication/questApplication/repository/UserRepository.java
package com.questApplication.questApplication.repository;

import com.questApplication.questApplication.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findAllByStatusNot(String status, Pageable pageable);
    Optional<User> findByIdAndStatusNot(Long id, String status);
    Optional<User> findByUsernameAndStatusNot(String username, String status);
    boolean existsByUsername(String username);
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/SuccessResult.java
package com.questApplication.questApplication.core.utilities.result;

public class SuccessResult extends Result {
    public SuccessResult() {
        super(true);
    }

    public SuccessResult(String message) {
        super(true, message);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/ErrorResult.java
package com.questApplication.questApplication.core.utilities.result;


public class ErrorResult extends Result {
    public ErrorResult() {
        super(false);
    }

    public ErrorResult(String message) {
        super(false, message);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/ErrorDataResult.java
package com.questApplication.questApplication.core.utilities.result;

public class ErrorDataResult<T> extends DataResult<T> {
    public ErrorDataResult(T data, String message) {
        super(data, false, message);
    }

    public ErrorDataResult(T data) {
        super(data, false);
    }

    public ErrorDataResult(String message) {
        super(null, false, message);
    }

    public ErrorDataResult() {
        super(null, false);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/Result.java
package com.questApplication.questApplication.core.utilities.result;

public class Result {
    private final boolean success;
    private final String message;

    public Result(boolean success) {
        this(success, null);
    }

    public Result(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}

----
src/main/java/com/questApplication/questApplication/core/utilities/result/SuccessDataResult.java
package com.questApplication.questApplication.core.utilities.result;

public class SuccessDataResult<T> extends DataResult<T> {
    public SuccessDataResult(T data, String message) {
        super(data, true, message);
    }

    public SuccessDataResult(T data) {
        super(data, true);
    }

    public SuccessDataResult(String message) {
        super(null, true, message);
    }

    public SuccessDataResult() {
        super(null, true);
    }
}
----
src/main/java/com/questApplication/questApplication/core/utilities/result/DataResult.java
package com.questApplication.questApplication.core.utilities.result;


public class DataResult<T> extends Result {
    private final T data;

    public DataResult(T data, boolean success, String message) {
        super(success, message);
        this.data = data;
    }

    public DataResult(T data, boolean success) {
        this(data, success, null);
    }

    public T getData() {
        return data;
    }
}
----
src/main/java/com/questApplication/questApplication/entity/Post.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Entity
@Table(name = "posts")
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;

    private String title;
    private String text;
    private String status;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @OneToMany(mappedBy = "post")
    private List<Like> likes;

    @OneToMany(mappedBy = "post")
    private List<Comment> comments;
}

----
src/main/java/com/questApplication/questApplication/entity/User.java
package com.questApplication.questApplication.entity;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    Long id;

    String username;
    String password;
    String status;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Post> posts;

    @OneToMany(mappedBy = "user")
    private List<Comment> comments;

    @OneToMany(mappedBy = "user")
    private List<Like> likes;
}

----
src/main/java/com/questApplication/questApplication/entity/Like.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name="likes")
public class Like {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    Long id;

    String status;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;

    @ManyToOne
    @JoinColumn(name = "comment_id")
    private Comment comment;
}

----
src/main/java/com/questApplication/questApplication/entity/Comment.java
package com.questApplication.questApplication.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Data
@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String text;
    private String status;

    @CreationTimestamp
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;

    @OneToMany(mappedBy = "comment")
    private List<Like> likes;


}

----
src/main/java/com/questApplication/questApplication/entity/dto/PostDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class PostDTO {
    private Long id;
    private String title;
    private String status;
    private String text;
    private LocalDateTime createdAt;
    private UserDTO user;
    private List<LikeDTO> likes;
    private List<CommentDTO> comments;
}
----
src/main/java/com/questApplication/questApplication/entity/dto/LikeDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

@Data
public class LikeDTO {
    private Long id;
    private String status;
    private Long userId;
    private Long postId;
    private Long commentId;
}
----
src/main/java/com/questApplication/questApplication/entity/dto/UserDTO.java
package com.questApplication.questApplication.entity.dto;

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private String password;
    private String status;

    public Long getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public String getPassword() { return password; }
    public String getStatus() { return status; }

    public void setId(Long id) { this.id = id; }
    public void setUsername(String username) { this.username = username; }
    public void setEmail(String email) { this.email = email; }
    public void setPassword(String password) { this.password = password; }
    public void setStatus(String status) { this.status = status; }
}
----
src/main/java/com/questApplication/questApplication/entity/dto/CommentDTO.java
package com.questApplication.questApplication.entity.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CommentDTO {
    private Long id;
    private String text;
    private String status;
    private LocalDateTime createdAt;
    private Long userId;
    private Long postId;
    private List<Long> likeIds;

}
----
src/main/java/com/questApplication/questApplication/business/concretes/PostManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.PostService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Post;
import com.questApplication.questApplication.entity.dto.PostDTO;
import com.questApplication.questApplication.mapper.PostMapper;
import com.questApplication.questApplication.repository.PostRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class PostManager implements PostService {
    private static final Logger logger = LoggerFactory.getLogger(PostManager.class);
    private final PostRepository postRepository;
    private final PostMapper postMapper;

    @Autowired
    public PostManager(PostRepository postRepository, PostMapper postMapper) {
        this.postRepository = postRepository;
        this.postMapper = postMapper;
    }

    @Override
    public DataResult<Page<PostDTO>> getAllPosts(Pageable pageable) {
        logger.info("Tüm gönderiler getiriliyor. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Post> posts = postRepository.findAllByStatusNot("D", pageable);
            Page<PostDTO> postDTOs = posts.map(postMapper::toDTO);
            logger.info("Toplam {} gönderi başarıyla getirildi", postDTOs.getTotalElements());
            return new SuccessDataResult<>(postDTOs, "Gönderiler başarıyla getirildi");
        } catch (Exception e) {
            logger.error("Gönderiler getirilirken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Gönderiler getirilirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<PostDTO> getPostById(Long id) {
        logger.info("{} ID'li gönderi getiriliyor", id);
        try {
            Post post = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (post != null) {
                PostDTO postDTO = postMapper.toDTO(post);
                logger.info("{} ID'li gönderi başarıyla getirildi", id);
                return new SuccessDataResult<>(postDTO, "Gönderi başarıyla getirildi");
            } else {
                logger.warn("{} ID'li gönderi bulunamadı", id);
                return new ErrorDataResult<>(null, "Gönderi bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gönderi getirilirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Gönderi getirilirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<Page<PostDTO>> getPostsByUserId(Long userId, Pageable pageable) {
        logger.info("{} ID'li kullanıcının gönderileri getiriliyor. Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Post> posts = postRepository.findByUserIdAndStatusNot(userId, "D", pageable);
            Page<PostDTO> postDTOs = posts.map(postMapper::toDTO);
            logger.info("{} ID'li kullanıcının {} gönderisi başarıyla getirildi", userId, postDTOs.getTotalElements());
            return new SuccessDataResult<>(postDTOs, "Kullanıcı gönderileri başarıyla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcının gönderileri getirilirken bir hata oluştu", userId, e);
            return new ErrorDataResult<>(null, "Kullanıcı gönderileri getirilirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> createPost(PostDTO postDTO) {
        logger.info("Yeni gönderi oluşturuluyor");
        try {
            Post post = postMapper.toEntity(postDTO);
            post.setStatus("A"); // Active
            Post savedPost = postRepository.save(post);
            PostDTO savedPostDTO = postMapper.toDTO(savedPost);
            logger.info("{} ID'li yeni gönderi başarıyla oluşturuldu", savedPostDTO.getId());
            return new SuccessDataResult<>(savedPostDTO, "Gönderi başarıyla oluşturuldu");
        } catch (Exception e) {
            logger.error("Gönderi oluşturulurken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Gönderi oluşturulurken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> updatePost(Long id, PostDTO postDTO) {
        logger.info("{} ID'li gönderi güncelleniyor", id);
        try {
            Post existingPost = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingPost != null) {
                Post updatedPost = postMapper.toEntity(postDTO);
                updatedPost.setId(id);
                updatedPost.setStatus("U"); // Updated
                Post savedPost = postRepository.save(updatedPost);
                PostDTO savedPostDTO = postMapper.toDTO(savedPost);
                logger.info("{} ID'li gönderi başarıyla güncellendi", id);
                return new SuccessDataResult<>(savedPostDTO, "Gönderi başarıyla güncellendi");
            } else {
                logger.warn("{} ID'li gönderi bulunamadı", id);
                return new ErrorDataResult<>(null, "Güncellenecek gönderi bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gönderi güncellenirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Gönderi güncellenirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public Result deletePost(Long id) {
        logger.info("{} ID'li gönderi siliniyor (soft delete)", id);
        try {
            Post post = postRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (post != null) {
                post.setStatus("D"); // Deleted
                postRepository.save(post);
                logger.info("{} ID'li gönderi başarıyla silindi (soft delete)", id);
                return new SuccessResult("Gönderi başarıyla silindi");
            } else {
                logger.warn("{} ID'li gönderi bulunamadı", id);
                return new ErrorResult("Silinecek gönderi bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gönderi silinirken bir hata oluştu", id, e);
            return new ErrorResult("Gönderi silinirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<PostDTO> activatePost(Long id) {
        logger.info("{} ID'li gönderi aktifleştiriliyor", id);
        try {
            Post post = postRepository.findById(id).orElse(null);
            if (post != null) {
                if (!post.getStatus().equals("A")) {
                    post.setStatus("A"); // Active
                    Post savedPost = postRepository.save(post);
                    PostDTO activatedPostDTO = postMapper.toDTO(savedPost);
                    logger.info("{} ID'li gönderi başarıyla aktifleştirildi", id);
                    return new SuccessDataResult<>(activatedPostDTO, "Gönderi başarıyla aktifleştirildi");
                } else {
                    logger.warn("{} ID'li gönderi zaten aktif", id);
                    return new ErrorDataResult<>(null, "Gönderi zaten aktif");
                }
            } else {
                logger.warn("{} ID'li gönderi bulunamadı", id);
                return new ErrorDataResult<>(null, "Aktifleştirilecek gönderi bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li gönderi aktifleştirilirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Gönderi aktifleştirilirken bir hata oluştu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/concretes/LikeManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.LikeService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Like;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import com.questApplication.questApplication.mapper.LikeMapper;
import com.questApplication.questApplication.repository.LikeRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class LikeManager implements LikeService {
    private static final Logger logger = LoggerFactory.getLogger(LikeManager.class);
    private final LikeRepository likeRepository;
    private final LikeMapper likeMapper;

    public LikeManager(LikeRepository likeRepository, LikeMapper likeMapper) {
        this.likeRepository = likeRepository;
        this.likeMapper = likeMapper;
    }

    @Override
    public DataResult<Page<LikeDTO>> getAllLikes(Pageable pageable) {
        logger.info("Tüm beğeniler getiriliyor, Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Like> likes = likeRepository.findAll(pageable);
            Page<LikeDTO> likeDTOs = likes.map(likeMapper::toDTO);
            logger.info("Toplam {} beğeni başarıyla getirildi", likeDTOs.getTotalElements());
            return new SuccessDataResult<>(likeDTOs, "Tüm beğeniler başarıyla getirildi");
        } catch (Exception e) {
            logger.error("Beğeniler getirilirken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Beğeniler getirilirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<Page<LikeDTO>> getLikesByPostId(Long postId, Pageable pageable) {
        logger.info("{} ID'li gönderinin beğenileri getiriliyor, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Like> likes = likeRepository.findByPostId(postId, pageable);
            Page<LikeDTO> likeDTOs = likes.map(likeMapper::toDTO);
            logger.info("{} ID'li gönderinin {} beğenisi başarıyla getirildi", postId, likeDTOs.getTotalElements());
            return new SuccessDataResult<>(likeDTOs, "Gönderi beğenileri başarıyla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gönderinin beğenileri getirilirken bir hata oluştu", postId, e);
            return new ErrorDataResult<>(null, "Gönderi beğenileri getirilirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public Result createLike(LikeDTO likeDTO) {
        logger.info("Yeni beğeni oluşturuluyor");
        try {
            if (likeRepository.existsByPostIdAndUserId(likeDTO.getPostId(), likeDTO.getUserId())) {
                logger.warn("Bu gönderi zaten bu kullanıcı tarafından beğenilmiş");
                return new ErrorResult("Bu gönderiyi zaten beğenmişsiniz");
            }
            Like like = likeMapper.toEntity(likeDTO);
            likeRepository.save(like);
            logger.info("Yeni beğeni başarıyla oluşturuldu");
            return new SuccessResult("Beğeni başarıyla oluşturuldu");
        } catch (Exception e) {
            logger.error("Beğeni oluşturulurken bir hata oluştu", e);
            return new ErrorResult("Beğeni oluşturulurken bir hata oluştu");        }
    }

    @Override
    public DataResult<Long> getLikeCountForPost(Long postId) {
        logger.info("{} ID'li gönderinin beğeni sayısı getiriliyor", postId);
        try {
            long likeCount = likeRepository.countByPostId(postId);
            logger.info("{} ID'li gönderinin beğeni sayısı: {}", postId, likeCount);
            return new SuccessDataResult<>(likeCount, "Gönderi beğeni sayısı başarıyla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gönderinin beğeni sayısı getirilirken bir hata oluştu", postId, e);
            return new ErrorDataResult<>(null, "Gönderi beğeni sayısı getirilirken bir hata oluştu");
        }
    }


}
----
src/main/java/com/questApplication/questApplication/business/concretes/UserManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.UserService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.User;
import com.questApplication.questApplication.entity.dto.UserDTO;
import com.questApplication.questApplication.mapper.UserMapper;
import com.questApplication.questApplication.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserManager implements UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserManager.class);
    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public UserManager(UserRepository userRepository, UserMapper userMapper, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.userMapper = userMapper;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public DataResult<Page<UserDTO>> getAllUsers(Pageable pageable) {
        logger.info("Tüm kullanıcılar getiriliyor. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<User> users = userRepository.findAllByStatusNot("D", pageable);
            Page<UserDTO> userDTOs = users.map(userMapper::toDTO);
            logger.info("Toplam {} kullanıcı başarıyla getirildi", userDTOs.getTotalElements());
            return new SuccessDataResult<>(userDTOs, "Kullanıcılar başarıyla getirildi");
        } catch (Exception e) {
            logger.error("Kullanıcılar getirilirken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Kullanıcılar getirilirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<UserDTO> getUserById(Long id) {
        logger.info("{} ID'li kullanıcı getiriliyor", id);
        try {
            User user = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (user != null) {
                UserDTO userDTO = userMapper.toDTO(user);
                logger.info("{} ID'li kullanıcı başarıyla getirildi", id);
                return new SuccessDataResult<>(userDTO, "Kullanıcı başarıyla getirildi");
            } else {
                logger.warn("{} ID'li kullanıcı bulunamadı", id);
                return new ErrorDataResult<>(null, "Kullanıcı bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcı getirilirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Kullanıcı getirilirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<UserDTO> createUser(UserDTO userDTO) {
        logger.info("Yeni kullanıcı oluşturuluyor");
        try {
            if (userRepository.existsByUsername(userDTO.getUsername())) {
                logger.warn("Bu kullanıcı adı zaten kullanılıyor: {}", userDTO.getUsername());
                return new ErrorDataResult<>(null, "Bu kullanıcı adı zaten kullanılıyor");
            }

            User user = userMapper.toEntity(userDTO);
            user.setPassword(passwordEncoder.encode(userDTO.getPassword()));
            user.setStatus("A"); // Active
            User savedUser = userRepository.save(user);
            UserDTO savedUserDTO = userMapper.toDTO(savedUser);
            logger.info("{} ID'li yeni kullanıcı başarıyla oluşturuldu", savedUserDTO.getId());
            return new SuccessDataResult<>(savedUserDTO, "Kullanıcı başarıyla oluşturuldu");
        } catch (Exception e) {
            logger.error("Kullanıcı oluşturulurken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Kullanıcı oluşturulurken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<UserDTO> updateUser(Long id, UserDTO userDTO) {
        logger.info("{} ID'li kullanıcı güncelleniyor", id);
        try {
            User existingUser = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingUser != null) {
                User updatedUser = userMapper.toEntity(userDTO);
                updatedUser.setId(id);
                updatedUser.setStatus("U");

                if (userDTO.getPassword() == null || userDTO.getPassword().isEmpty()) {
                    updatedUser.setPassword(existingUser.getPassword());
                } else {
                    updatedUser.setPassword(passwordEncoder.encode(userDTO.getPassword()));
                }

                User savedUser = userRepository.save(updatedUser);
                UserDTO savedUserDTO = userMapper.toDTO(savedUser);
                logger.info("{} ID'li kullanıcı başarıyla güncellendi", id);
                return new SuccessDataResult<>(savedUserDTO, "Kullanıcı başarıyla güncellendi");
            } else {
                logger.warn("{} ID'li kullanıcı bulunamadı", id);
                return new ErrorDataResult<>(null, "Güncellenecek kullanıcı bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcı güncellenirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Kullanıcı güncellenirken bir hata oluştu");
        }
    }


    @Override
    @Transactional
    public Result deleteUser(Long id) {
        logger.info("{} ID'li kullanıcı siliniyor (soft delete)", id);
        try {
            User user = userRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (user != null) {
                user.setStatus("D");
                userRepository.save(user);
                logger.info("{} ID'li kullanıcı başarıyla silindi (soft delete)", id);
                return new SuccessResult("Kullanıcı başarıyla silindi");
            } else {
                logger.warn("{} ID'li kullanıcı bulunamadı", id);
                return new ErrorResult("Silinecek kullanıcı bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcı silinirken bir hata oluştu", id, e);
            return new ErrorResult("Kullanıcı silinirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<UserDTO> getUserByUsername(String username) {
        logger.info("{} kullanıcı adına sahip kullanıcı getiriliyor", username);
        try {
            User user = userRepository.findByUsernameAndStatusNot(username, "D").orElse(null);
            if (user != null) {
                UserDTO userDTO = userMapper.toDTO(user);
                logger.info("{} kullanıcı adına sahip kullanıcı başarıyla getirildi", username);
                return new SuccessDataResult<>(userDTO, "Kullanıcı başarıyla getirildi");
            } else {
                logger.warn("{} kullanıcı adına sahip kullanıcı bulunamadı", username);
                return new ErrorDataResult<>(null, "Kullanıcı bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} kullanıcı adına sahip kullanıcı getirilirken bir hata oluştu", username, e);
            return new ErrorDataResult<>(null, "Kullanıcı getirilirken bir hata oluştu");
        }
    }


    @Override
    @Transactional
    public DataResult<UserDTO> activateUser(Long id) {
        logger.info("{} ID'li kullanıcı aktifleştiriliyor", id);
        try {
            User user = userRepository.findById(id).orElse(null);
            if (user != null) {
                if (!user.getStatus().equals("A")) {
                    user.setStatus("A");
                    User savedUser = userRepository.save(user);
                    UserDTO activatedUserDTO = userMapper.toDTO(savedUser);
                    logger.info("{} ID'li kullanıcı başarıyla aktifleştirildi", id);
                    return new SuccessDataResult<>(activatedUserDTO, "Kullanıcı başarıyla aktifleştirildi");
                } else {
                    logger.warn("{} ID'li kullanıcı zaten aktif", id);
                    return new ErrorDataResult<>(null, "Kullanıcı zaten aktif");
                }
            } else {
                logger.warn("{} ID'li kullanıcı bulunamadı", id);
                return new ErrorDataResult<>(null, "Aktifleştirilecek kullanıcı bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcı aktifleştirilirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Kullanıcı aktifleştirilirken bir hata oluştu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/concretes/CommentManager.java
package com.questApplication.questApplication.business.concretes;

import com.questApplication.questApplication.business.abstracts.CommentService;
import com.questApplication.questApplication.core.utilities.result.*;
import com.questApplication.questApplication.entity.Comment;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import com.questApplication.questApplication.mapper.CommentMapper;
import com.questApplication.questApplication.repository.CommentRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class CommentManager implements CommentService {
    private static final Logger logger = LoggerFactory.getLogger(CommentManager.class);
    private final CommentRepository commentRepository;
    private final CommentMapper commentMapper;

    @Autowired
    public CommentManager(CommentRepository commentRepository, CommentMapper commentMapper) {
        this.commentRepository = commentRepository;
        this.commentMapper = commentMapper;
    }

    @Override
    public DataResult<Page<CommentDTO>> getCommentsByPostId(Long postId, Pageable pageable) {
        logger.info("{} ID'li gönderinin yorumları getiriliyor. Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Comment> comments = commentRepository.findByPostIdAndStatusNot(postId, "D", pageable);
            Page<CommentDTO> commentDTOs = comments.map(commentMapper::toDTO);
            logger.info("{} ID'li gönderinin {} yorumu başarıyla getirildi", postId, commentDTOs.getTotalElements());
            return new SuccessDataResult<>(commentDTOs, "Yorumlar başarıyla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li gönderinin yorumları getirilirken bir hata oluştu", postId, e);
            return new ErrorDataResult<>(null, "Yorumlar getirilirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<Page<CommentDTO>> getCommentsByUserId(Long userId, Pageable pageable) {
        logger.info("{} ID'li kullanıcının yorumları getiriliyor. Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        try {
            Page<Comment> comments = commentRepository.findByUserIdAndStatusNot(userId, "D", pageable);
            Page<CommentDTO> commentDTOs = comments.map(commentMapper::toDTO);
            logger.info("{} ID'li kullanıcının {} yorumu başarıyla getirildi", userId, commentDTOs.getTotalElements());
            return new SuccessDataResult<>(commentDTOs, "Kullanıcının yorumları başarıyla getirildi");
        } catch (Exception e) {
            logger.error("{} ID'li kullanıcının yorumları getirilirken bir hata oluştu", userId, e);
            return new ErrorDataResult<>(null, "Kullanıcının yorumları getirilirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<CommentDTO> createComment(CommentDTO commentDTO) {
        logger.info("Yeni yorum oluşturuluyor");
        try {
            Comment comment = commentMapper.toEntity(commentDTO);
            comment.setStatus("A"); // Active
            Comment savedComment = commentRepository.save(comment);
            CommentDTO savedCommentDTO = commentMapper.toDTO(savedComment);
            logger.info("{} ID'li yeni yorum başarıyla oluşturuldu", savedCommentDTO.getId());
            return new SuccessDataResult<>(savedCommentDTO, "Yorum başarıyla oluşturuldu");
        } catch (Exception e) {
            logger.error("Yorum oluşturulurken bir hata oluştu", e);
            return new ErrorDataResult<>(null, "Yorum oluşturulurken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public DataResult<CommentDTO> updateComment(Long id, CommentDTO commentDTO) {
        logger.info("{} ID'li yorum güncelleniyor", id);
        try {
            Comment existingComment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (existingComment != null) {
                Comment updatedComment = commentMapper.toEntity(commentDTO);
                updatedComment.setId(id);
                updatedComment.setStatus("U"); // Updated
                Comment savedComment = commentRepository.save(updatedComment);
                CommentDTO savedCommentDTO = commentMapper.toDTO(savedComment);
                logger.info("{} ID'li yorum başarıyla güncellendi", id);
                return new SuccessDataResult<>(savedCommentDTO, "Yorum başarıyla güncellendi");
            } else {
                logger.warn("{} ID'li yorum bulunamadı", id);
                return new ErrorDataResult<>(null, "Güncellenecek yorum bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum güncellenirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Yorum güncellenirken bir hata oluştu");
        }
    }

    @Override
    @Transactional
    public Result deleteComment(Long id) {
        logger.info("{} ID'li yorum siliniyor (soft delete)", id);
        try {
            Comment comment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (comment != null) {
                comment.setStatus("D"); // Deleted
                commentRepository.save(comment);
                logger.info("{} ID'li yorum başarıyla silindi (soft delete)", id);
                return new SuccessResult("Yorum başarıyla silindi");
            } else {
                logger.warn("{} ID'li yorum bulunamadı", id);
                return new ErrorResult("Silinecek yorum bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum silinirken bir hata oluştu", id, e);
            return new ErrorResult("Yorum silinirken bir hata oluştu");
        }
    }

    @Override
    public DataResult<CommentDTO> getCommentById(Long id) {
        logger.info("{} ID'li yorum getiriliyor", id);
        try {
            Comment comment = commentRepository.findByIdAndStatusNot(id, "D").orElse(null);
            if (comment != null) {
                CommentDTO commentDTO = commentMapper.toDTO(comment);
                logger.info("{} ID'li yorum başarıyla getirildi", id);
                return new SuccessDataResult<>(commentDTO, "Yorum başarıyla getirildi");
            } else {
                logger.warn("{} ID'li yorum bulunamadı", id);
                return new ErrorDataResult<>(null, "Yorum bulunamadı");
            }
        } catch (Exception e) {
            logger.error("{} ID'li yorum getirilirken bir hata oluştu", id, e);
            return new ErrorDataResult<>(null, "Yorum getirilirken bir hata oluştu");
        }
    }
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/LikeService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface LikeService {
    DataResult<Page<LikeDTO>> getAllLikes ( Pageable pageable );
    DataResult<Page<LikeDTO>> getLikesByPostId(Long postId, Pageable pageable);
    Result createLike(LikeDTO likeDTO);
    DataResult<Long> getLikeCountForPost(Long postId);
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/UserService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.UserDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface UserService {
    DataResult<Page<UserDTO>> getAllUsers(Pageable pageable);
    DataResult<UserDTO> getUserById(Long id);
    DataResult<UserDTO> createUser(UserDTO userDTO);
    DataResult<UserDTO> updateUser(Long id, UserDTO userDTO);
    Result deleteUser(Long id);
    DataResult<UserDTO> getUserByUsername(String username);
    DataResult<UserDTO> activateUser(Long id);
}
----
src/main/java/com/questApplication/questApplication/business/abstracts/CommentService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface CommentService {
    DataResult<Page<CommentDTO>> getCommentsByPostId(Long postId, Pageable pageable);
    DataResult<Page<CommentDTO>> getCommentsByUserId(Long userId, Pageable pageable);
    DataResult<CommentDTO> createComment(CommentDTO commentDTO);
    DataResult<CommentDTO> updateComment(Long id, CommentDTO commentDTO);
    Result deleteComment(Long id);
    DataResult<CommentDTO> getCommentById(Long id);
}

----
src/main/java/com/questApplication/questApplication/business/abstracts/PostService.java
package com.questApplication.questApplication.business.abstracts;

import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.PostDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface PostService {
    DataResult<Page<PostDTO>> getAllPosts(Pageable pageable);
    DataResult<PostDTO> getPostById(Long id);
    DataResult<Page<PostDTO>> getPostsByUserId(Long userId, Pageable pageable);
    DataResult<PostDTO> createPost(PostDTO postDTO);
    DataResult<PostDTO> updatePost(Long id, PostDTO postDTO);
    Result deletePost(Long id);
    DataResult<PostDTO> activatePost(Long id);
}
----
src/main/java/com/questApplication/questApplication/mapper/CommentMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Comment;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface CommentMapper {
    CommentDTO toDTO( Comment comment);
    Comment toEntity(CommentDTO commentDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/PostMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Post;
import com.questApplication.questApplication.entity.dto.PostDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring", uses = {UserMapper.class, LikeMapper.class, CommentMapper.class})
public interface PostMapper {
    PostDTO toDTO(Post post);
    Post toEntity(PostDTO postDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/LikeMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.Like;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface LikeMapper {
    LikeDTO toDTO( Like like);
    Like toEntity(LikeDTO likeDTO);
}
----
src/main/java/com/questApplication/questApplication/mapper/UserMapper.java
package com.questApplication.questApplication.mapper;

import com.questApplication.questApplication.entity.User;
import com.questApplication.questApplication.entity.dto.UserDTO;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface UserMapper {
    UserDTO toDTO(User user);
    User toEntity(UserDTO userDTO);
}
----
src/main/java/com/questApplication/questApplication/api/controller/LikeController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.LikeService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.LikeDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/likes")
@Tag(name = "Beğeni Denetleyicisi", description = "Beğeni işlemlerini yönetir")
public class LikeController {

    private static final Logger logger = LoggerFactory.getLogger(LikeController.class);
    private final LikeService likeService;

    public LikeController(LikeService likeService) {
        this.likeService = likeService;
    }

    @GetMapping("/")
    @Operation(summary = "Tüm beğenileri getir", description = "Tüm beğenileri sayfalanmış şekilde getirir")
    public ResponseEntity<DataResult<Page<LikeDTO>>> getAllLikes(Pageable pageable) {
        logger.debug("getAllLikes isteği alındı. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<LikeDTO>> result = likeService.getAllLikes(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }


    @GetMapping("/post/{postId}")
    @Operation(summary = "Gönderi ID'sine göre beğenileri getir", description = "Belirli bir gönderiye ait sayfalanmış beğenileri getirir")
    public ResponseEntity<DataResult<Page<LikeDTO>>> getLikesByPostId(
            @PathVariable Long postId,
            Pageable pageable) {
        logger.debug("getLikesByPostId isteği alındı. Post ID: {}, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<LikeDTO>> result = likeService.getLikesByPostId(postId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping("/")
    @Operation(summary = "Yeni bir beğeni oluştur", description = "Yeni bir beğeni oluşturur ve sonucu döndürür")
    public ResponseEntity<Result> createLike(@Valid @RequestBody LikeDTO likeDTO) {
        logger.debug("createLike isteği alındı");
        Result result = likeService.createLike(likeDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @GetMapping("/count/{postId}")
    @Operation(summary = "Gönderi beğeni sayısını getir", description = "Belirli bir gönderinin toplam beğeni sayısını getirir")
    public ResponseEntity<DataResult<Long>> getLikeCountForPost(@PathVariable Long postId) {
        logger.debug("getLikeCountForPost isteği alındı. Post ID: {}", postId);
        DataResult<Long> result = likeService.getLikeCountForPost(postId);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluştu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluştu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/CommentController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.CommentService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.CommentDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/comments")
@Tag(name = "Yorum Denetleyicisi", description = "Yorum işlemlerini yönetir")
public class CommentController {

    private static final Logger logger = LoggerFactory.getLogger(CommentController.class);
    private final CommentService commentService;

    public CommentController(CommentService commentService) {
        this.commentService = commentService;
    }

    @GetMapping("/post/{postId}")
    @Operation(summary = "Gönderi ID'sine göre yorumları getir", description = "Belirli bir gönderiye ait sayfalanmış yorumları getirir")
    public ResponseEntity<DataResult<Page<CommentDTO>>> getCommentsByPostId(
            @PathVariable Long postId,
            Pageable pageable) {
        logger.debug("getCommentsByPostId isteği alındı. Post ID: {}, Sayfa: {}, Boyut: {}", postId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<CommentDTO>> result = commentService.getCommentsByPostId(postId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "Kullanıcı ID'sine göre yorumları getir", description = "Belirli bir kullanıcıya ait sayfalanmış yorumları getirir")
    public ResponseEntity<DataResult<Page<CommentDTO>>> getCommentsByUserId(
            @PathVariable Long userId,
            Pageable pageable) {
        logger.debug("getCommentsByUserId isteği alındı. User ID: {}, Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<CommentDTO>> result = commentService.getCommentsByUserId(userId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping
    @Operation(summary = "Yeni bir yorum oluştur", description = "Yeni bir yorum oluşturur ve oluşturulan yorumu döndürür")
    public ResponseEntity<DataResult<CommentDTO>> createComment(@Valid @RequestBody CommentDTO commentDTO) {
        logger.debug("createComment isteği alındı");
        DataResult<CommentDTO> result = commentService.createComment(commentDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir yorumu güncelle", description = "Mevcut bir yorumu günceller ve güncellenmiş yorumu döndürür")
    public ResponseEntity<DataResult<CommentDTO>> updateComment(
            @PathVariable Long id,
            @Valid @RequestBody CommentDTO commentDTO) {
        logger.debug("updateComment isteği alındı. Comment ID: {}", id);
        DataResult<CommentDTO> result = commentService.updateComment(id, commentDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir yorumu sil", description = "Bir yorumu ID'sine göre siler")
    public ResponseEntity<Result> deleteComment(@PathVariable Long id) {
        logger.debug("deleteComment isteği alındı. Comment ID: {}", id);
        Result result = commentService.deleteComment(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye göre yorum getir", description = "Belirli bir yorumu ID'sine göre getirir")
    public ResponseEntity<DataResult<CommentDTO>> getCommentById(@PathVariable Long id) {
        logger.debug("getCommentById isteği alındı. Comment ID: {}", id);
        DataResult<CommentDTO> result = commentService.getCommentById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluştu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluştu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/PostController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.PostService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.PostDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/posts")
@Tag(name = "Gönderi Denetleyicisi", description = "Gönderi işlemlerini yönetir")
public class PostController {

    private static final Logger logger = LoggerFactory.getLogger(PostController.class);
    private final PostService postService;

    public PostController(PostService postService) {
        this.postService = postService;
    }

    @GetMapping
    @Operation(summary = "Tüm gönderileri getir", description = "Tüm gönderileri sayfalanmış şekilde getirir")
    public ResponseEntity<DataResult<Page<PostDTO>>> getAllPosts(Pageable pageable) {
        logger.debug("getAllPosts isteği alındı. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<PostDTO>> result = postService.getAllPosts(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye göre gönderi getir", description = "Belirli bir gönderiyi ID'sine göre getirir")
    public ResponseEntity<DataResult<PostDTO>> getPostById(@PathVariable Long id) {
        logger.debug("getPostById isteği alındı. Post ID: {}", id);
        DataResult<PostDTO> result = postService.getPostById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping
    @Operation(summary = "Yeni bir gönderi oluştur", description = "Yeni bir gönderi oluşturur ve oluşturulan gönderiyi döndürür")
    public ResponseEntity<DataResult<PostDTO>> createPost(@Valid @RequestBody PostDTO postDTO) {
        logger.debug("createPost isteği alındı");
        DataResult<PostDTO> result = postService.createPost(postDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir gönderiyi güncelle", description = "Mevcut bir gönderiyi günceller ve güncellenmiş gönderiyi döndürür")
    public ResponseEntity<DataResult<PostDTO>> updatePost(@PathVariable Long id, @Valid @RequestBody PostDTO postDTO) {
        logger.debug("updatePost isteği alındı. Post ID: {}", id);
        DataResult<PostDTO> result = postService.updatePost(id, postDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir gönderiyi sil", description = "Bir gönderiyi ID'sine göre siler")
    public ResponseEntity<Result> deletePost(@PathVariable Long id) {
        logger.debug("deletePost isteği alındı. Post ID: {}", id);
        Result result = postService.deletePost(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "Kullanıcının gönderilerini getir", description = "Belirli bir kullanıcının gönderilerini sayfalanmış şekilde getirir")
    public ResponseEntity<DataResult<Page<PostDTO>>> getPostsByUserId(@PathVariable Long userId, Pageable pageable) {
        logger.debug("getPostsByUserId isteği alındı. User ID: {}, Sayfa: {}, Boyut: {}", userId, pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<PostDTO>> result = postService.getPostsByUserId(userId, pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluştu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluştu");
    }
}
----
src/main/java/com/questApplication/questApplication/api/controller/UserController.java
package com.questApplication.questApplication.api.controller;

import com.questApplication.questApplication.business.abstracts.UserService;
import com.questApplication.questApplication.core.utilities.result.DataResult;
import com.questApplication.questApplication.core.utilities.result.Result;
import com.questApplication.questApplication.entity.dto.UserDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Kullanıcı Denetleyicisi", description = "Kullanıcı işlemlerini yönetir")
public class UserController {

    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/")
    @Operation(summary = "Tüm kullanıcıları getir", description = "Tüm kullanıcıları sayfalanmış şekilde getirir")
    public ResponseEntity<DataResult<Page<UserDTO>>> getAllUsers(Pageable pageable) {
        logger.debug("getAllUsers isteği alındı. Sayfa: {}, Boyut: {}", pageable.getPageNumber(), pageable.getPageSize());
        DataResult<Page<UserDTO>> result = userService.getAllUsers(pageable);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @GetMapping("/{id}")
    @Operation(summary = "ID'ye göre kullanıcı getir", description = "Belirli bir kullanıcıyı ID'sine göre getirir")
    public ResponseEntity<DataResult<UserDTO>> getUserById(@PathVariable Long id) {
        logger.debug("getUserById isteği alındı. User ID: {}", id);
        DataResult<UserDTO> result = userService.getUserById(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @PostMapping("/")
    @Operation(summary = "Yeni bir kullanıcı oluştur", description = "Yeni bir kullanıcı oluşturur ve oluşturulan kullanıcıyı döndürür")
    public ResponseEntity<DataResult<UserDTO>> createUser(@Valid @RequestBody UserDTO userDTO) {
        logger.debug("createUser isteği alındı");
        DataResult<UserDTO> result = userService.createUser(userDTO);
        return result.isSuccess()
                ? ResponseEntity.status(HttpStatus.CREATED).body(result)
                : ResponseEntity.status(HttpStatus.BAD_REQUEST).body(result);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Bir kullanıcıyı güncelle", description = "Mevcut bir kullanıcıyı günceller ve güncellenmiş kullanıcıyı döndürür")
    public ResponseEntity<DataResult<UserDTO>> updateUser(@PathVariable Long id, @Valid @RequestBody UserDTO userDTO) {
        logger.debug("updateUser isteği alındı. User ID: {}", id);
        DataResult<UserDTO> result = userService.updateUser(id, userDTO);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Bir kullanıcıyı sil", description = "Bir kullanıcıyı ID'sine göre siler")
    public ResponseEntity<Result> deleteUser(@PathVariable Long id) {
        logger.debug("deleteUser isteği alındı. User ID: {}", id);
        Result result = userService.deleteUser(id);
        return result.isSuccess()
                ? ResponseEntity.ok(result)
                : ResponseEntity.status(HttpStatus.NOT_FOUND).body(result);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception e) {
        logger.error("Beklenmeyen bir hata oluştu: ", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Beklenmeyen bir hata oluştu");
    }
}
--END--